import java.io.BufferedReader;
import java.io.FileReader;
import java.io.IOException;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;

public class Main {
	public static void main(String[] args) {

		for (int i = 0; i < args.length; i++) {
			String fileName = args[i];

			try {
				BufferedReader reader = new BufferedReader(new FileReader(fileName));
				StringBuilder input = new StringBuilder();
				String line;
				int lineNumber = 1;

				while ((line = reader.readLine()) != null) {
					lineNumber++;
					if (line.trim().startsWith("#")) {
						line = line.replaceAll(line, "\n");
						input.append(line);
						//line = "\n";
						continue; // Ignore comments
					}
					input.append(line).append("\n");
				}

				Lexer lexer = new Lexer(input.toString());
				List<Token> tokens = lexer.tokenize();

				for (Token token : tokens) {
					System.out.println(token + " ");
				}

				reader.close();
			} catch (IOException e) {
				System.out.println("Erro ao ler o arquivo: " + e.getMessage());
			}
		}
	}
}

class Token {
	private TokenType type;
	private String lexeme;
	private int lineNumber;

	public Token(TokenType type, String lexeme, int lineNumber) {
		this.type = type;
		this.lexeme = lexeme;
		this.lineNumber = lineNumber;
	}

	public TokenType getType() {
		return type;
	}

	public String getLexeme() {
		return lexeme;
	}

	public int getLineNumber() {
		return lineNumber;
	}

	@Override
	public String toString() {
		if(type == null) {
			return "Erro lexico na linha: " + lineNumber + " caractere " + lexeme + " n√£o reconhecido."; 
		}
		return "Linha: " + lineNumber + " <" + type + ", \"" + lexeme + "\">";
	}
}

enum TokenType {
	PCDec, PCProg, PCInt, PCReal, PCLer, PCImprimir, PCSe, PCSenao, PCEntao, PCEnqto, PCIni, PCFim, OpAritMult,
	OpAritDiv, OpAritSoma, OpAritSub, OpRelMenor, OpRelMenorIgual, OpRelMaior, OpRelMaiorIgual, OpRelIgual, OpRelDif,
	OpBoolE, OpBoolOu, IniDelim, FimDelim, Atrib, AbrePar, FechaPar, Var, NumInt, NumReal, Cadeia, EOF
}

class Lexer {
	private String input;
	private int position;
	private int lineNumber;

	public Lexer(String input) {
		this.input = input;
		this.position = 0;
		this.lineNumber = 1;
	}

	public List<Token> tokenize() {
		List<Token> tokens = new ArrayList<>();
		while (position < input.length()) {
			char currentChar = input.charAt(position);
			if (currentChar == '\n') {
				position++;
				lineNumber++;
			} else if (Character.isWhitespace(currentChar)) {
				position++;
			} else if (currentChar == '[') {
				tokens.add(new Token(TokenType.IniDelim, "[", lineNumber));
				position++;
			} else if (currentChar == ']') {
				tokens.add(new Token(TokenType.FimDelim, "]", lineNumber));
				position++;
			} else if (currentChar == '(') {
				tokens.add(new Token(TokenType.AbrePar, "(", lineNumber));
				position++;
			} else if (currentChar == ')') {
				tokens.add(new Token(TokenType.FechaPar, ")", lineNumber));
				position++;
			} else if (currentChar == '<') {
				if (position + 1 < input.length() && input.charAt(position + 1) == '<') {
					tokens.add(new Token(TokenType.Atrib, "<<", lineNumber));
					position += 2;
				} else if(position + 1 < input.length() && input.charAt(position + 1) == '>'){
					tokens.add(new Token(TokenType.OpRelDif, "<>", lineNumber));
					position++;
				}else {
					tokens.add(new Token(TokenType.OpRelMenor, "<", lineNumber));
					position++;
				}
			} else if (currentChar == '>') {
				if (position + 1 < input.length() && input.charAt(position + 1) == '=') {
					tokens.add(new Token(TokenType.OpRelMaiorIgual, ">=", lineNumber));
					position += 2;
				} else {
					tokens.add(new Token(TokenType.OpRelMaior, ">", lineNumber));
					position++;
				}
			} else if (currentChar == '=') {
				if (position + 1 < input.length() && input.charAt(position + 1) == '=') {
					tokens.add(new Token(TokenType.OpRelIgual, "==", lineNumber));
					position += 2;
				} else {
					tokens.add(new Token(null, "=", lineNumber));
					position++;
				}
			} else if (currentChar == '+') {
				tokens.add(new Token(TokenType.OpAritSoma, "+", lineNumber));
				position++;
			} else if (currentChar == '-') {
				tokens.add(new Token(TokenType.OpAritSub, "-", lineNumber));
				position++;
			} else if (currentChar == '*') {
				tokens.add(new Token(TokenType.OpAritMult, "*", lineNumber));
				position++;
			} else if (currentChar == '/') {
				tokens.add(new Token(TokenType.OpAritDiv, "/", lineNumber));
				position++;
			}else if(currentChar == '"') {
				StringBuilder aux = new StringBuilder();
				position++;
				currentChar = input.charAt(position);
				while(currentChar != '"') {
					aux.append(currentChar);
					position++;
					currentChar = input.charAt(position);
				}
				tokens.add(new Token(TokenType.Cadeia, aux.toString(),lineNumber));
				position++;
			}
			else if (Character.isLetter(currentChar)) {
				if (Character.isUpperCase(currentChar)) {
					String lexeme = readWord();
					TokenType type = getKeywordType(lexeme);
					tokens.add(new Token(TokenType.Var, lexeme, lineNumber));
				} else {
					String lexeme = readWord();
					TokenType type = getKeywordType(lexeme);
					tokens.add(new Token(type, lexeme, lineNumber));
				}

			} else if (Character.isDigit(currentChar)) {
				String lexeme = readNumber();
				tokens.add(new Token(lexeme.contains(".") ? TokenType.NumReal : TokenType.NumInt, lexeme, lineNumber));
			} else {
				// Assuming any other character as invalid token
				position++;
			}
		}
		tokens.add(new Token(TokenType.EOF, "", lineNumber));
		return tokens;
	}

	private String readWord() {
		StringBuilder builder = new StringBuilder();
		while (position < input.length()
				&& (Character.isLetter(input.charAt(position)) || Character.isDigit(input.charAt(position)))) {
			builder.append(input.charAt(position));
			position++;
		}
		return builder.toString();
	}

	private String readNumber() {
		StringBuilder builder = new StringBuilder();
		while (position < input.length()
				&& (Character.isDigit(input.charAt(position)) || input.charAt(position) == '.')) {
			builder.append(input.charAt(position));
			position++;
		}
		return builder.toString();
	}

	private TokenType getKeywordType(String lexeme) {
		HashMap<String, TokenType> keywords = new HashMap<>();
		keywords.put("dec", TokenType.PCDec);
		keywords.put("prog", TokenType.PCProg);
		keywords.put("integer", TokenType.PCInt);
		keywords.put("float", TokenType.PCReal);
		keywords.put("read", TokenType.PCLer);
		keywords.put("print", TokenType.PCImprimir);
		keywords.put("if", TokenType.PCSe);
		keywords.put("else", TokenType.PCSenao);
		keywords.put("then", TokenType.PCEntao);
		keywords.put("while", TokenType.PCEnqto);
		keywords.put("start", TokenType.PCIni);
		keywords.put("end", TokenType.PCFim);

		return keywords.get(lexeme);
	}
}