import java.io.BufferedReader;
import java.io.FileReader;
import java.io.IOException;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;

public class Main {
    public static void main(String[] args) {
        if (args.length != 1) {
            System.out.println("Uso: java Main <arquivo>");
            return;
        }

        String fileName = args[0];

        try {
            BufferedReader reader = new BufferedReader(new FileReader(fileName));
            StringBuilder input = new StringBuilder();
            String line;

            while ((line = reader.readLine()) != null) {
                input.append(line).append("\n");
            }

            Lexer lexer = new Lexer(input.toString());
            List<Token> tokens = lexer.tokenize();

            for (Token token : tokens) {
                System.out.println(token + " ");
            }

            reader.close();
        } catch (IOException e) {
            System.out.println("Erro ao ler o arquivo: " + e.getMessage());
        }
    }
}

class Token {
    private TokenType type;
    private String lexeme;

    public Token(TokenType type, String lexeme) {
        this.type = type;
        this.lexeme = lexeme;
    }

    public TokenType getType() {
        return type;
    }

    public String getLexeme() {
        return lexeme;
    }

    @Override
    public String toString() {
        return "<" + type + ", \"" + lexeme + "\">";
    }
}

enum TokenType {
    PCDec, PCProg, PCInt, PCReal, PCLer, PCImprimir, PCSe, PCSenao, PCEntao, PCEnqto, PCIni, PCFim,
    OpAritMult, OpAritDiv, OpAritSoma, OpAritSub,
    OpRelMenor, OpRelMenorIgual, OpRelMaior, OpRelMaiorIgual, OpRelIgual, OpRelDif,
    OpBoolE, OpBoolOu,
    IniDelim, FimDelim,
    Atrib,
    AbrePar, FechaPar,
    Var,
    NumInt,
    NumReal,
    Cadeia,
    EOF
}

class Lexer {
    private String input;
    private int position;

    public Lexer(String input) {
        this.input = input;
        this.position = 0;
    }

    public List<Token> tokenize() {
        List<Token> tokens = new ArrayList<>();
        while (position < input.length()) {
            char currentChar = input.charAt(position);
            if (Character.isWhitespace(currentChar)) {
                position++;
            } else if (currentChar == '[') {
                tokens.add(new Token(TokenType.IniDelim, "["));
                position++;
            } else if (currentChar == ']') {
                tokens.add(new Token(TokenType.FimDelim, "]"));
                position++;
            } else if (currentChar == '(') {
                tokens.add(new Token(TokenType.AbrePar, "("));
                position++;
            } else if (currentChar == ')') {
                tokens.add(new Token(TokenType.FechaPar, ")"));
                position++;
            } else if (currentChar == '<') {
                if (position + 1 < input.length() && input.charAt(position + 1) == '<') {
                    tokens.add(new Token(TokenType.Atrib, "<<"));
                    position += 2;
                } else {
                    tokens.add(new Token(TokenType.OpRelMenor, "<"));
                    position++;
                }
            } else if (currentChar == '>') {
                if (position + 1 < input.length() && input.charAt(position + 1) == '=') {
                    tokens.add(new Token(TokenType.OpRelMaiorIgual, ">="));
                    position += 2;
                } else {
                    tokens.add(new Token(TokenType.OpRelMaior, ">"));
                    position++;
                }
            } else if (currentChar == '=') {
                if (position + 1 < input.length() && input.charAt(position + 1) == '=') {
                    tokens.add(new Token(TokenType.OpRelIgual, "=="));
                    position += 2;
                } else {
                    // Assuming single '=' as invalid token
                    position++;
                }
            } else if (currentChar == '!') {
                if (position + 1 < input.length() && input.charAt(position + 1) == '=') {
                    tokens.add(new Token(TokenType.OpRelDif, "!="));
                    position += 2;
                } else {
                    // Assuming '!' as invalid token
                    position++;
                }
            } else if (currentChar == '+') {
                tokens.add(new Token(TokenType.OpAritSoma, "+"));
                position++;
            } else if (currentChar == '-') {
                tokens.add(new Token(TokenType.OpAritSub, "-"));
                position++;
            } else if (currentChar == '*') {
                tokens.add(new Token(TokenType.OpAritMult, "*"));
                position++;
            } else if (currentChar == '/') {
                tokens.add(new Token(TokenType.OpAritDiv, "/"));
                position++;
            } else if (Character.isLetter(currentChar)) {
                String lexeme = readWord();
                TokenType type = getKeywordType(lexeme);
                tokens.add(new Token(type != null ? type : TokenType.Var, lexeme));
            } else if (Character.isDigit(currentChar)) {
                String lexeme = readNumber();
                tokens.add(new Token(lexeme.contains(".") ? TokenType.NumReal : TokenType.NumInt, lexeme));
            } else {
                // Assuming any other character as invalid token
                position++;
            }
        }
        tokens.add(new Token(TokenType.EOF, ""));
        return tokens;
    }

    private String readWord() {
        StringBuilder builder = new StringBuilder();
        while (position < input.length() && (Character.isLetter(input.charAt(position)) || Character.isDigit(input.charAt(position)))) {
            builder.append(input.charAt(position));
            position++;
        }
        return builder.toString();
    }

    private String readNumber() {
        StringBuilder builder = new StringBuilder();
        while (position < input.length() && (Character.isDigit(input.charAt(position)) || input.charAt(position) == '.')) {
            builder.append(input.charAt(position));
            position++;
        }
        return builder.toString();
    }

    private TokenType getKeywordType(String lexeme) {
        HashMap<String, TokenType> keywords = new HashMap<>();
        keywords.put("dec", TokenType.PCDec);
        keywords.put("prog", TokenType.PCProg);
        keywords.put("integer", TokenType.PCInt);
        keywords.put("float", TokenType.PCReal);
        keywords.put("read", TokenType.PCLer);
        keywords.put("print", TokenType.PCImprimir);
        keywords.put("if", TokenType.PCSe);
        keywords.put("else", TokenType.PCSenao);
        keywords.put("then", TokenType.PCEntao);
        keywords.put("while", TokenType.PCEnqto);
        keywords.put("start", TokenType.PCIni);
        keywords.put("end", TokenType.PCFim);

        return keywords.get(lexeme);
    }
}